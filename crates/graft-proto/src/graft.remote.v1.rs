// @generated
// This file is @generated by prost-build.
/// A Volume has a top level control file stored at
/// `{prefix}/{vid}/control`
/// Control files are immutable.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Control {
    /// The Volume ID stored as a 16 byte GID.
    #[prost(message, optional, tag="1")]
    pub vid: ::core::option::Option<::graft_core::gid::VolumeId>,
    /// The parent reference if this Volume is a fork.
    #[prost(message, optional, tag="2")]
    pub parent: ::core::option::Option<VolumeRef>,
    /// The creation timestamp of this Volume.
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// When a Volume is forked, a ref is first written to the parent Volume:
/// `{prefix}/{parent-vid}/forks/{fork-vid}`
/// Forks are immutable.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fork {
    /// The VID of the fork.
    #[prost(message, optional, tag="1")]
    pub fork_vid: ::core::option::Option<::graft_core::gid::VolumeId>,
    /// The fork point. Must match the parent field in the Fork's Control file.
    #[prost(message, optional, tag="2")]
    pub parent: ::core::option::Option<VolumeRef>,
}
/// A reference to a Volume at a particular LSN.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeRef {
    /// The Volume ID stored as a 16 byte GID.
    #[prost(message, optional, tag="1")]
    pub vid: ::core::option::Option<::graft_core::gid::VolumeId>,
    /// The referenced LSN.
    #[prost(uint64, tag="2")]
    pub lsn: u64,
}
/// A Volume's CheckpointSet is stored at `{prefix}/{vid}/checkpoints`.
/// CheckpointSets are updated by the checkpointer via compare-and-swap.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSet {
    /// The Volume ID stored as a 16 byte GID.
    #[prost(message, optional, tag="1")]
    pub vid: ::core::option::Option<::graft_core::gid::VolumeId>,
    /// The list of checkpoint LSNs.
    #[prost(uint64, repeated, tag="2")]
    pub lsns: ::prost::alloc::vec::Vec<u64>,
}
/// A snapshot of a Volume.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    /// The Volume ID stored as a 16 byte GID.
    #[prost(message, optional, tag="1")]
    pub vid: ::core::option::Option<::graft_core::gid::VolumeId>,
    /// The LSN of the Volume at this Snapshot.
    #[prost(uint64, tag="2")]
    pub lsn: u64,
    /// The Volume's page count at this Snapshot.
    #[prost(uint32, tag="3")]
    pub page_count: u32,
}
/// Commits are stored at `{prefix}/{vid}/log/{lsn}`.
/// A commit may not include a SegmentRef if only the Volume's page count has
/// changed. This happens when the Volume is extended or truncated without
/// additional writes.
/// Commits are immutable.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Commit {
    /// The Volume Snapshot at this Commit.
    #[prost(message, optional, tag="1")]
    pub snapshot: ::core::option::Option<Snapshot>,
    /// An optional 256 bit CommitHash of this Commit.
    /// Always present on Remote Volume commits.
    /// May be omitted on Local commits.
    #[prost(bytes="bytes", optional, tag="2")]
    pub hash: ::core::option::Option<::prost::bytes::Bytes>,
    /// If this Commit contains any pages, `segment_ref` records details on the
    /// relevant Segment.
    #[prost(message, optional, tag="3")]
    pub segment_ref: ::core::option::Option<SegmentRef>,
    /// If this commit is a checkpoint, this timestamp is set and records the time
    /// the commit was made a checkpoint
    #[prost(message, optional, tag="4")]
    pub checkpoint_ts: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentRef {
    /// The 16 byte Segment ID.
    #[prost(message, optional, tag="1")]
    pub sid: ::core::option::Option<::graft_core::gid::SegmentId>,
    /// The set of pageidxs stored in this Segment.
    /// Serialized using Splinter encoding.
    #[prost(bytes="bytes", tag="2")]
    pub splinter: ::prost::bytes::Bytes,
    /// An index of frames contained by the Segment.
    /// Empty on Local Segments which have not been encoded and uploaded to object
    /// storage.
    #[prost(message, repeated, tag="3")]
    pub frames: ::prost::alloc::vec::Vec<SegmentFrame>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SegmentFrame {
    /// The length of the compressed frame in bytes.
    #[prost(uint32, tag="1")]
    pub frame_size: u32,
    /// The last pageidx stored in the frame
    #[prost(uint32, tag="2")]
    pub last_pageidx: u32,
}
// @@protoc_insertion_point(module)
