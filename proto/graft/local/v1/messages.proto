syntax = "proto3";
package graft.local.v1;

import "graft/remote/v1/messages.proto";
import "graft/core/v1/gid.proto";
import "graft/core/v1/lsn.proto";
import "graft/core/v1/handle_id.proto";
import "graft/core/v1/commit_hash.proto";

message LocalCheckpointSet {
  // The etag from the last time we pulled the CheckpointSet, used to only pull
  // changed CheckpointSets
  bytes etag = 1;

  // The set of checkpoint LSNs.
  graft.core.v1.LSNSet lsns = 2;
}

message VolumeHandle {
  // The id of the Volume Handle
  graft.core.v1.HandleId id = 1;

  // References to the local and remote Volumes, along with LSNs representing
  // their latest successful synchronization.
  graft.remote.v1.VolumeRef local = 2;
  optional graft.remote.v1.VolumeRef remote = 3;

  // Presence of the pending_commit field means that the Push operation is in
  // the process of committing to the remote. If no such Push job is currently
  // running (i.e. it was interrupted), this field must be used to resume or
  // abort the commit process.
  optional PendingCommit pending_commit = 4;
}

message PendingCommit {
  // The resulting remote LSN that the push job is attempting to create
  graft.core.v1.LSN remote_lsn = 1;

  // The associated 256 bit blake3 commit hash. This is used to determine
  // whether or not the commit has landed in the remote, in the case that we are
  // interrupted while attempting to push.
  graft.core.v1.CommitHash commit_hash = 2;
}
